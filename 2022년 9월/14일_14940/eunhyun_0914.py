'''
지도의 크기 n과 m이 주어진다. 
n은 세로의 크기, m은 가로의 크기다.(2 ≤ n ≤ 1000, 2 ≤ m ≤ 1000)

다음 n개의 줄에 m개의 숫자가 주어진다. 
0은 갈 수 없는 땅이고 1은 갈 수 있는 땅, 2는 목표지점이다. 
입력에서 2는 단 한개이다.

출력
각 지점에서 목표지점까지의 거리를 출력한다. 
원래 갈 수 없는 땅인 위치는 0을 출력하고, 
원래 갈 수 있는 땅인 부분 중에서 도달할 수 없는 위치는 -1을 출력한다.

예제 입력 1  복사
15 15
2 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 0 0 0 0 1
1 1 1 1 1 1 1 1 1 1 0 1 1 1 1
1 1 1 1 1 1 1 1 1 1 0 1 0 0 0
1 1 1 1 1 1 1 1 1 1 0 1 1 1 1

예제 출력 1  복사
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
7 8 9 10 11 12 13 14 15 16 17 18 19 20 21
8 9 10 11 12 13 14 15 16 17 18 19 20 21 22
9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
11 12 13 14 15 16 17 18 19 20 0 0 0 0 25
12 13 14 15 16 17 18 19 20 21 0 29 28 27 26
13 14 15 16 17 18 19 20 21 22 0 30 0 0 0
14 15 16 17 18 19 20 21 22 23 0 31 32 33 34
'''

from collections import deque
import sys

input = sys.stdin.readline

n, m = map(int, input().rstrip().split())

pan = []
ans = [[-1] * m for _ in range(n)]
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

x, y = 0, 0

for i in range(n):
    tmp = list(map(int, input().split()))

    if 2 in tmp:
        j = tmp.index(2)
        x, y = i, j

    pan.append(tmp)

q = deque()
q.append((x,y))
ans[x][y] = 0

while q:
    x, y = q.popleft()

    for i in range(4):
        new_x, new_y = x + dx[i], y + dy[i]

        if 0 <= new_x < n and 0 <= new_y < m:
        
            if pan[new_x][new_y] == 1 and ans[new_x][new_y] == -1:
                q.append((new_x, new_y))
                ans[new_x][new_y] = ans[x][y] + 1

            elif ans[new_x][new_y] != 0 and ans[x][y] + 1 < ans[new_x][new_y]:
                q.append((new_x, new_y))
                ans[new_x][new_y] = ans[x][y] + 1
            
for x in range(n):
    if -1 in ans[x]:
        for y in range(m):
            if ans[x][y] == -1:
                if pan[x][y] == 0:
                    ans[x][y] = 0
        
    print(*ans[x])


    
